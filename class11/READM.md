# 数据库进阶

## 📚数据库进阶

### 1.关系模式

##### E-R模型

![img](https://s1.ax1x.com/2022/10/05/xlxyfx.md.png)

如图，E-R模型的一些基本概念 ：

- 方框：实体
- 椭圆：属性
- 棱形框：联系
- 连线圆圈：特殊化
- 双线矩形：弱实体(是某个实体的特殊化)

E-R模型反映的是实体与实体的关系，以及关系模式的转化

###### 1:1联系

![img](https://s1.ax1x.com/2022/10/05/xlxrkR.png)

**校长：**姓名、性别、支撑、年龄

**学校：**校名、地址、电话

**任职：**任职时间、姓名、校名

校长与学校之间通过任职建立联系

**联系可以合并到任一实体**



###### 1:n联系

![img](https://s1.ax1x.com/2022/10/05/xlxRXD.png)

一个客户对应多个账户

一个账户对应一个客户

**联系并到多的一端**

客户（…）

账户（…开户时间）



###### n:m联系

![img](https://s1.ax1x.com/2022/10/05/xlx26O.png)

学生与课程多对多联系

**联系单独分成一个表**



##### 补充

- **一个实体型转换为一个关系模式**

- 三个以上实体间的一个多元联系：

  ![img](https://s1.ax1x.com/2022/10/05/xlxg1K.png)

**最少**可以转化为(3+1)

**A B C各一个 D(A主键 B主键 C主键)**



### 2.关系代数

![](https://img-blog.csdnimg.cn/20210101195248917.PNG?x-oss-process=image,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDU4NDQ1,size_16,color_FFFFFF,t_70#pic_center)

- 并：取并集
- 交：取交集
- 差：取差
- 笛卡尔积：每条记录直接相乘合并，记录数变为MxN
- 投影(∏)：类似于选择列
- 选择(σ): 从R关系表内选择出符合关系的

![](https://s1.ax1x.com/2022/10/05/xlzAuF.md.png)



##### 等值连接

###### 等值连接：R.A = S.B(A、B属性名可不同也可以相同)

**语法：R ⋈AθBS = { tr ⌒ ts | tr ∈ R ∧ ts ∈ S ∧ tr[A] = ts[B] }**

> 其中，R和S为关系表，A、B分别是关系R、S上的可比属性组(A、B两个属性组的域相同，就称为可比属性组)

> θ称为比值符，也就是>、<、=号； 当θ两边的属性相等时，等值S连接成立；

等值连接其结果是从关系R和S的笛卡尔积中选出属性组AB相等的元组，即：

σ(A=B)(R×S)

![img](https://s1.ax1x.com/2022/10/05/x1ShFA.md.png)

结果上，从S×C的笛卡尔积内选择出S.CNO = C.CNO的元组，即：
$$
σ(CNO=CNO)(S×C)
$$

##### 自然连接

R.A = S.A(必须有相同的属性名才可以进行自然连接，即具有相同的域)

**特殊的等值连接，比较的分量必须是同一属性组**

在等值连接的基础上**去掉重复的属性列**



![img](https://s1.ax1x.com/2022/10/05/x1SHOS.md.png)

结果上，从S×C的笛卡尔积内选择出S.CNO = C.CNO的元组并去重，即：
$$
Π(Name,Sex,Age,CNO,CN){σ(CNO=CNO)(S×C)}
$$
范式

### 3.范式

> 范式就是一张数据表结构所符合的某种设计标准的级别

先来了解几个概念

- **候选键：**唯一标识元组，并且无冗余
- **主键：**从候选键中任选一个
- **外键：**其他关系的**主键**
- **键：**可以认为是表中**字段**

如下所示，候选键只有id(**因为其他任一字段都无法起到唯一标识作用)**

| id   | name | sex  | birthday |
| ---- | ---- | ---- | -------- |
| 1    | 小明 | 男   | 20       |
| 2    | 小华 | 女   | 22       |



![](https://s1.ax1x.com/2022/10/06/x1fakQ.png)

**部分依赖** 通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB

**完全依赖** 通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB

**传递依赖** 通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么说C传递依赖于A



##### 第一范式(1NF)

在关系模式R中，当且仅当所有域只包含**原子值**，即所有属性都是**不可再分**的数据项，则称关系模式R是第一范式

| id   | name | sex  | birthday |
| ---- | ---- | ---- | -------- |
| 1    | 小明 | 男   | 20       |
| 2    | 小华 | 女   | 22       |

##### 第二范式

当且仅当关系模式R是第一范式，且每一个属性**完全依赖候选键**(没有不完全依赖)，则称关系模式是第二范式

##### 第三范式

当且仅当关系模式R是第二范式，且R中**没有非主属性传递依赖于候选键**时，则称关系模式R是第三范式

##### BC范式

设R是一个关系模式，F是它的依赖集，R属于BCNF当且仅当其F中**每个依赖的决定因素必定包含R的某个候选码**

> 也就是说，只要属性或属性组A能够决定任何一个属性B，则A的子集中必须有候选键

![](https://s1.ax1x.com/2022/10/06/x14azn.md.png)



### 4.Mysql进阶

#### 🛠sql进阶

##### sql基础回顾

###### **子查询**

> 子查询是嵌套在另一个语句，如：select update delete insert中的查询

```sql
select name,age from student where name in(
	select name from student where sex='男'
)order by id desc;
```

我们将这条语句拆解一下

最外层：

```sql
select name,age from student where name in(..)order by id desc;
```

里层:

```sql
select name from student where sex='男';
```

外层在里层结果的基础上再进行查询

最后的:

```sql
order by id desc;
```

意思是结果按id排序，降序(desc)

升序是`asc`

###### 聚合查询

基本聚合函数

- COUNT：计算表中的记录数（行数）
- SUM：计算表中数值列中数据的合计值
- AVG：计算表中数值列中数据的平均值
- MAX：求出表中任意列中数据的最大值
- MIN：求出表中任意列中数据的最小值

相关法则：

- COUNT函数的结果**根据参数的不同而不同**。COUNT(*)会得到包含NULL的数据行数，而COUNT(<列名>)会得到NULL之外的数据行数。
- 聚合函数**会将NULL排除在外**。但**COUNT(*)例外**，并不会排除NULL。
- MAX/MIN函数几乎适用于所有数据类型的列。**SUM/AVG函数只适用于数值类型的列**。
- 想要计算值的**种类**时，可以在COUNT函数的参数中使用DISTINCT。
- 在聚合函数的参数中使**用DISTINCT**，可以删除重复数据。



##### 字符函数

```sql
#CONCAT函数
SELECT CONCAT(user_id,Order_date) #拼接两个字段
from ord;

#LOWER与UPPER
SELECT LOWER("ABCDEFG");#转换为小写
SELECT UPPER("abdefg");#转化为大写

#LEFT（str,n）取str左边起前n个字符
SELECT LEFT("abcdefg",3)#返回字符串右边3个字符

#REPLACE(str,"s1","s2")使用s2代替str中的s1
SELECT REPLACE("ABCDEFG","CDE","cde");#使用cde代替字符串ABCDEFG 中的CDE

#REVERSE()函数
SELECT REVERSE("ABCDEFG");#反转字符
```

##### 日期与时间函数

```sql
#now()函数
SELECT now() #选择当前日期时间

#CURDATE()函数
SELECT CURDATE()#选择当前日期

#CURTIME()获取当前时间点
SELECT CURTIME()#选择当前时间点

#YEAR(),MONTH(),DAY()#选择当前的年,月，日
SELECT YEAR(NOW()),MONTH(NOW()),DAY(NOW())#选择当前的年,月，日

#DATEDIFF()#两日期之差，单位为天数。
SELECT DATEDIFF("2021-04-20","2021-04-10")#时间差，以天数为单位

#DATE_FORMAT转换时间格式
SELECT DATE_FORMAT(NOW(),'%Y-%m-%d')#转换时间格式
```

##### 窗口函数

> 窗口函数可以进行排序、生成序列号等一般的聚合函数无法实现的高级操作。

详见：https://www.cnblogs.com/vin-c/archive/2022/06/15/16379156.html



#### 索引

##### 什么是索引？

> 官方介绍索引是帮助MySQL**高效获取数据**的**数据结构**。简单来讲，数据库索引就像是书前面的目录，能**加快数据库的查询速度**。
>
> 事实上，索引是一种数据结构，用于帮助我们在**大量数据**中快速定位到我们想要查找的数据。

但对于海量数据来说，它的目录也是很大的，不可能全部存储在内存中，因此**索引往往是存储在磁盘上的文件中**（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。



##### 索引分类

###### 单列索引

> 一个索引**只包含单个列**，但**一个表中可以有多个单列索引**。
>
> 1、普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一 点。
>
> 2、**唯一索引**：索引列中的值必须是唯一的，但是允许为空值。
>
> 3、**主键索引**：是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引）。

###### 组合索引

> 在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

###### 全文索引

> 全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。



##### 索引的数据结构

是B+树

![8a0e2789eb3b491286cdd287fc89fe23(1)](http://typora.fengxiangrui.top/1671622396.png)

了解即可 :https://blog.csdn.net/jiang_wang01/article/details/113739230



#### 事务特性

###### 事务定义

> - 事务：事务是一个**最小的不可在分的工作单元**；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务是一个最小的工作单元)
> - 一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成。
> - **事务只和DML语句有关**，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同。

###### 特性

- 原子性：事务的原子性操作，对数据的操作要么全部成功，要么全部失败，实现事务的原子性是基于事务的Redo/Undoh机制。
-  一致性：执行事务的前后状态一致，理解为数据的一致性。
-  隔离性：事务之间互相隔离，不受影响，与事务的隔离级别有关。
-  持久性：事务提交之后，事务的状态会被持久化到数据库中。

###### 事务的隔离级别

1.「读已提交」：即能够「读取到那些已经提交」的数据。

2.「读未提交」：即能够「读取到没有被提交」的数据。

3.「可重复读」：可重复读指的是在一个事务内，最开始读到的数据和事务结束前的「任意时刻读到的同一批数据都是一致的」。

4.「可串行化」：最高事务隔离级别，不管多少事务，都是「依次按序一个一个执行」。

###### 隔离性实现原理

> 是通过数据库锁的机制实现的

**隔离性分四个级别：**

**读未提交**：一个事务可以读到另外一个事务未提交的数据。脏读

实现：事务在读数据的时候并未对数据进行加锁。

事务在发生更新数据的瞬间，必须先对其加 行级共享锁，直到事务结束才释放。

举例：事务A读取某行记录时(没有加锁)，事务2也能对这行记录进行读取、更新。当事务B对该记录进行更新时，事务A读取该记录，能读到事务B对该记录的修改版本，即使该修改尚未被提交。

事务A更新某行记录时，事务B不能对这行记录做更新，直到事务A结束。

------

**读已提交：**一个事务可以读到另外一个事务提交的数据。不可重复读

实现：事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

原理：事务A读取某行记录时，事务B也能对这行记录进行读取、更新；当事务B对该记录进行更新时，事务A再次读取该记录，读到的只能是事务B对其更新前的版本，或者事务B提交后的版本。事务A更新某行记录时，事务B不能对这行记录做更新，直到事务1结束。

流程描述：事务A读操作会加上共享锁，事务B写操作时会加上排他锁，当事务B正在写操作时，事务A要读操作，发现有排他锁，事务A就会阻塞，等待排他锁释放(事务B写操作提交才会释放)，才能进行读操作。

------

**可重复读**

实现：事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

举例：事务A读取某行记录时，事务B也能对这行记录进行读取、更新；当事务B对该记录进行更新时，事务A再次读取该记录，读到的仍然是第一次读取的那个版本。事务A更新某行记录时，事务B不能对这行记录做更新，直到事务1结束。

------

**可串行化(Serializable) 写操作串联执行**

实现：事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；

事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

举例：事务A正在读取A表中的记录时，则事务B也能读取A表，但不能对A表做更新、新增、删除，直到事务A结束。事务A正在更新A表中的记录时，则事务B不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务A结束。

原理：在读操作时，加表级共享锁，事务结束时释放；写操作时候，加表级独占锁，事务结束时释放。

「MySQL的默认隔离级别是可重复读」数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。

------

**1.「脏读」**
脏读指的是「读到了其他事务未提交的数据」，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。
**2.「不可重复读」**
对比可重复读，不可重复读指的是在同一事务内，「不同的时刻读到的同一批数据可能是不一样的」。
**3.「幻读」**
幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现「好像刚刚的更改对于某些数据未起作用」，但其实是事务B刚插入进来的这就叫幻读。



###### 视图

> 视图是一个虚拟表，它可以像表一样进行curd操作，视图是**虚拟表**，本身**不存储数据**，而是按照指定的方式进行查询，其本质就是一条有名字的select语句：一到多张表的内容。视图的列来自于一个表或多个表，可以理解为一个复杂查询的sql语句设置了一个别名，所以视图不可以和表名重名，多用作查询，一般**不会通过视图去修改数据**。

优点：**限制数据库的访问**，简化查询，数据独立性，对同一数据的不同体现。

```sql
#两个表的关联查询可以创建成一个视图
create view view_test as(select s.id as id,s.name as name,g.age as age from user s,user_detail g where s.id=g.id);
```



#### sql注入

防止办法：

1、过滤掉一些常见的数据库操作关键字，或者通过系统函数来进行过滤

2、在 PHP 配置文件中将 Register_globals=off; 设置为关闭状态

3、SQL 语句书写的时候尽量不要省略小引号（tab 键上面那个）和单引号

4、提高数据库命名技巧，对于一些重要的字段根据程序的特点命名，取不易被猜到的

5、对于常用的方法加以封装，避免直接暴漏 SQL 语句

6、开启 PHP 安全模式 Safe_mode=on;

7、打开 magic_quotes_gpc 来防止 SQL 注入

8、控制错误信息，关闭错误提示信息，将错误信息写到系统日志

9、使用 mysqli 或 pdo 预处理





### 5.Redis进阶

##### 发布订阅模式

见:https://www.cnblogs.com/shenStudy/p/16796755.html

##### 常见问题

###### 缓存击穿：

当大量流量查询redis缓存中没有key而mysql中存在的，导致mysql崩掉

预防：该业务功能进行查询限制，及时将缓存写入redis中

解决：将key手动写入redis中，重启mysql

###### 缓存穿透：

当大量流量查询redis缓存中没有key而mysql中也没有，导致mysql崩掉

预防：缓存 空对象或默认操作值（一般这种设置需要服务器中业务代码进行特殊控制）

解决：缓存 空对象或默认操作值，重启mysql

###### 缓存雪崩：

当redis中key集体失效或redis宕机，导致缓存不可用，同时大量请求访问，导致mysql也崩掉

###### 预防：

key集体失效---配置多组失效时间、让其能够间接工作。

redis宕机--这种问题一般不可避免，一般采用集群方式尽量减轻单节点压力、异地多活防止单地机房多宕机

###### 解决：

手动从nginx或网关进行限流或转发到错误页面，重启redis,并将热点数据手动设置到redis中（数据预热），重启mysql，调整回转发



##### 三种集群模式

###### 主从复制

至少需要两台redis服务器，一台主节点（master）、一台从节点（slave），组成主从模式的Redis集群。通常来说，master主要负责写，slave主要负责读，主从模式实现了读写分离。

集群中有多台redis节点，就必须保证每个节点中的数据是一致的。redis中，为了保持数据一致性，数据总是从master复制到slave，这就是redis的主从复制。

**主从复制的作用：**

- 数据冗余：实现了数据的热备份，是持久化之外的另一种数据冗余方式
- 故障恢复：master故障时，slave可以提供服务，实现故障快速恢复
- 负载均衡：master负责写，slave负责读。在写少读多的场景下可以极大提高redis吞吐量
- 高可用基石：主从复制是redis哨兵模式和集群模式的基础。

**主从复制实现原理：**

主从复制过程主要可以分为3个阶段：连接建立阶段、数据同步阶段、命令传播阶段。

- 连接建立阶段：在主从节点之间建立连接，为数据同步做准备。
- 数据同步阶段：执行数据的全量（或增量）复制（复制RDB文件）
- 命令传播阶段：主节点将已执行的命令发送给从节点，从节点接收命令并执行，从而实现主从节点的数据一致性

主从模式中，一个主节点可以有多个从节点。为了减少主从复制对主节点的性能影响，一个从节点可以作为另外一个从节点的主节点进行主从复制。

**不足之处**：主节点宕机之后，需要手动拉起从节点来提供业务，不能达到高可用。



###### 哨兵模式[Sentinel]

> Redis Sentinel是Redis的高可用实现方案，它可以实现对redis的监控、通知和自动故障转移，当redis master挂掉之后，可以自动拉起slave提供业务，从而实现redis的高可用。**为了避免Sentinel本身出现单点故障**，Sentinel**自己也可采用集群模式**。

![uTools_1671628216642](https://typora.fengxiangrui.top/1671628224.png)



**Sentinel是一种特殊的redis节点**，每个sentinel节点会维护与其他redis节点（包括master/slave/sentinel）的心跳。

当一个sentinel节点与master节点的心跳丢失时，这个sentinel节点就会认为master节点出现了故障，处于不可用的状态，这种判定叫作主观下线（即sentinel节点自己主观认为master下线了）

之后，这个sentinel节点会与其他sentinel节点交换信息，如果发现认为主节点发生故障的sentinel节点的个数超过了某个阈值（**通常为sentinel节点总数的1/2+1，即超过半数**），则sentinel会认为master节点已经处于客观下线的状态，即大家都认为master故障不可用了。

之后，sentinel节点中会**选举**处一个sentinel leader来执行redis主节点的故障转移。

被选举出的 Sentinel 领导者进行故障转移的具体步骤如下：

（1）在从节点列表中选出一个节点作为新的主节点

- 过滤不健康或者不满足要求的节点；
- 选择 slave-priority（优先级）最高的从节点， 如果存在则返回， 不存在则继续；
- 选择复制偏移量最大的从节点 ， 如果存在则返回， 不存在则继续；
- 选择 runid 最小的从节点。

（2）Sentinel 领导者节点会对选出来的从节点执行 slaveof no one 命令让其成为主节点。

（3）Sentinel 领导者节点会向剩余的从节点发送命令，让他们从新的主节点上复制数据。

（4）Sentinel 领导者会将原来的主节点更新为从节点， 并对其进行监控， 当其恢复后命令它去复制新的主节点。



###### 集群模式

主从模式实现了数据的热备份，哨兵模式实现了redis的高可用。但是有一个问题，这两种模式都没有解决，这两种模式都只能有一个master节点负责写操作，在高并发的写操作场景，master节点就会成为性能瓶颈。

redis的集群模式中可以实现多个节点同时提供写操作，redis集群模式采用无中心结构，每个节点都保存数据，节点之间互相连接从而知道整个集群状态。

如图所示集群模式其实就是多个主从复制的结构组合起来的，每一个主从复制结构可以看成一个节点，那么上面的Cluster集群中就有三个节点。

![uTools_1671628368211](http://typora.fengxiangrui.top/1671628378.png)